# Tour Of Heroes Backend -
## Création d'un CRUD côté Back .

---

## Table des matieres
[1-Preparation de l'environement de travail](#1)
[2-Organisation du projet](#2)
[3-JPA, le point de départ du backend](#3)
[4-Les données](#4)
[5-Branchement de Spring à la base de données](#5)
[6-Test](#6)
[7-Le CRUD](#7)
[8-Le controlleur (HeroControler)](#8)
[9-c**R**ud](#9)
[10-c**R**ud , la suite](#10)
[11- cru**D**, Delete](#11)
[12-**C**rud, Create](#12)
[13-cr**U**d, update](#13)
[14-Premier bilan](#14)
[15-Quand ça marche c'est bien mais quand ça marche pas?](#15)
[16-Conclusion?](#16)
[17-Attention ça se "**CORS**"](#17)
[18-Aller plus loin](#18)
[19-JPA à la rescousse!](#19)

---

### 1-Preparation de l'environement de travail{#1}
Initialisation du projet avec [Spring Initializr].
Dépendances à ajouter:

- Spring Web
- JPA
- MySQL

Obtention d'un fichier zip à decompresser dans son dossier de travail. on peut ainsi
ouvrir le dossier avec son **IDE**.



### 2-Organisation du projet{#2}
le travail se fera essentiellement dans le dossier:
**<dossier de travail>/src/main/java**
C'est là que nous allons organiser nos classes dans different packages, à la racine de celui défini lors de la création du projet.

Comment organiser notre projet?
>nous allons utiliser l' architecture [MVC]. C'est la structure idéale pour ce projet, et des frameworks comme Angular ou Spring s'y conforment parfaitement.

Convention de nommage: Pour rappel, nous allons relier ce projet back au projet front créé avec angular. Son theme tournant autour des Heros, et pour rester coherent avec le front, nous allons creer notre back sous le même thème. Plus d'employés donc, mais des super-h"ros, ce qui est tout de même plus sympa, ah.

### 3-JPA, le point de départ du backend{#3}

Pour bénéficier de toute la puissance de Spring en matiére d'opérations sur les bases de données, nous allons devoir mettre en place une *interface* qui etendra la classe **JpaRepository**.
Cette manoeuvre se nomme la création d'un **Repository**. Un ensemble d'opérations offertes par JpaRepository pour manipuler les données d'une table dans une base de données.
Puisque nous allons "jouer" avec des héros, nous allons créer une classe **HerRepository** dans un package *Repository*, à la racine du package défini lors de la création du projet( package racine ).

        package <package racine>.Repository; 
        import org.springframework.data.jpa.repository.JpaRepository;
        interface EmployeeRepository extends JpaRepository<Hero, Long> {}
        
à noter: JpaRepository a besoin de 2 choses au moins pour fonctionner. Un objet, ici notre futur héros (nous allons créer la classe - et donc le type - Hero prochainement), et un id, ici de type Long. l'id est l'information première d'un element d'une base de données. JPA prend en charge les ids de maniere quasi autonome. (avec un peu de notre aide).

Il est temps de définir notre héros. Créons une classe **Hero** dans un package *Model*. et oui, notre héros, avant d'être du muscle, c'est de la donnée, et la donnée en MVC, on la range dans la catégorie Model. Notre classe aura pour l'instant que  propriétés:
- une id
- un nom
- un pouvoir

         import java.util.Objects;

        import javax.persistence.Entity;
        import javax.persistence.GeneratedValue;
        import javax.persistence.Id;

        @Entity
        class Employee {
        
          private @Id @GeneratedValue Long id;
          private String name;
          private String role;
        
          Employee() {}
        
          Employee(String name, String role) {
        
            this.name = name;
            this.role = role;
          }
        
          public Long getId() {
            return this.id;
          }
        
          public String getName() {
            return this.name;
          }
        
          public String getRole() {
            return this.role;
          }
        
          public void setId(Long id) {
            this.id = id;
          }
        
          public void setName(String name) {
            this.name = name;
          }

          public void setRole(String role) {
            this.role = role;
          }
        
          @Override
          public boolean equals(Object o) {
        
            if (this == o)
              return true;
            if (!(o instanceof Employee))
              return false;
            Employee employee = (Employee) o;
            return Objects.equals(this.id, employee.id) && Objects.equals(this.name, employee.name)
        && Objects.equals(this.role, employee.role);
              }
            
              @Override
              public int hashCode() {
                return Objects.hash(this.id, this.name, this.role);
              }
            
              @Override
              public String toString() {
                return "Employee{" + "id=" + this.id + ", name='" + this.name + '\'' + ", role='" + this.role + '\'' + '}';
            }
        }
        
Remarquons que notre classe à quelques termes un peu etranges. Ces instructions précédées de @ s'appelent des **annotations**. Placées avant ou aprés l'élément ciblé, elles informent Spring que ce sont des éléments particuliers. Spring les prend ainsi en charge et travail dessus en coulisses.

**@entity**:
**@Id @GeneratedValue** :

Sinon rien de neuf. Un constructeur ( attention toutefois, pas d'id dans le constructeur, c'est JPA qui va le gérer. ), des getters/setters, une fonction **hasCode** pour faire bonne figure et un **toString()** au cas où.


### 4-Les données{#4}

On quitte Spring un moment pour créer notre base de donnée. Elle sera pour l'instant très basique 
Nous pouvons utiliser DBeaver pour la creer, avec un script tel que celui-ci par exemple:

        DROP TABLE IF EXISTS `hero`;
        CREATE TABLE IF NOT EXISTS `hero` (
          `id` int NOT NULL AUTO_INCREMENT,
          `nom` varchar(50) NOT NULL,
          `pouvoir` varchar(100) NOT NULL,
          PRIMARY KEY (`id`)
        ) 
        
        INSERT INTO `hero` (`id`, `nom`, `pouvoir`) VALUES
        (1, 'Mystique', 'Peut prendre l\'apparence de ta n\'importe qui),
        (2, 'Cyclope', 'Un laser sort de ses yeux'),
        (3, 'Gambit', 'Rend les objets explosifs'),
        (4, 'Diablo', 'Peut se teleporter'),
        (5, 'Rogue', 'Absorbe les pouvoirs d\'autrui'),
        (6, 'Jubilee', 'Tire des feux d\'artifices'),
        (7, 'Juggernaut', 'I\'m the juggernaut, bitch!'),
        (8, 'Pr Xavier', 'Telepathe'),
        COMMIT;
        
C'est vraiment basique pour l'instant mais on etoffera plus tard. On structure, on mets en place, on fait tourner, et apres on ajoute des données et des fonctionnalités.

### 5-Branchement de Spring à la base de données{#5}

De retour dans notre IDE. Dans le dossier **Ressources** il existe un fichier nommé *application.properties*. c'est là que nous allons configurer Spring pour lier à notre DB

    # MySQL configuration
    
    spring.datasource.url=jdbc:mysql://localhost:3306/<nom de votre base de données>
    spring.datasource.username=<votre identifiant MySQL>
    spring.datasource.password=<votre mot de pase MySQL>
    spring.jpa.show-sql=true
    spring.jpa.hibernate.ddl-auto=update
    spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
    
spring.jpa.show-sql=true: affiche les requetes sql dans la console, partique!
spring.jpa.hibernate.ddl-auto=update: comportement de jpa vis à vis de la DB. ici on la mets à jour à chaque action
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect: dialect utilisé, histoire tout le monde parle la même langue. MySQL_Dialect où _ est votre version de MySQL.

### 6-Test{#6}

on se place sur notre classe principale pour lancer l'application. normalement, Spring nous laisse tranquille.

On va etre prêt pour mettre en place..

### 7-Le CRUD{#7}

Le deroulement d'un crud, dans le cas d'une application web comme la notre, se déroule en plusieurs etapes:

- Coté FRONT, une action envoie une requete http sous forme d'url.
- On la reçoit côté BACK via le **controleur**, qui va transmetre le necessaire à un **service**. Le service va implementer les fonctions d'une Interface **HeroRepository**, qui étend elle-même la classe **JpaRepositoty**..
- HeroRepository beneficie donc des fonctions toutes pretes de JPA en rapport avec les manipulations dans la DB. Et comme toute interface, elle peut declarer ses propres méthodes.
- Les données récupérées, on refait le chemin inverse. le controleur BACK renvoie ce dont le controleur du  FRONT a besoin pour ses propres traitements, ses propres services.




### 8-Le controlleur (HeroControler){#8}

Le controlleur propose les points d'entrées de notre Front et des requetes que ce dernier apporte. On peut imaginer un messager, à la croisée de plusieurs chemins, qui, à la reception d'une requete, prend la bonne voie pour aller chercher le service adapté.

Notre base de données comporte déjà quelques infos, nous allons pouvoir faire le CRUD dessus, tout d'abord en allant toutes les chercher ( le R de CRUD, Read).

Coté controleur (HeroControler), voilà ce qui va se passer niveau code:

        @GetMapping("/all")
        public ResponseEntity<List<Hero>> getAllHeroes(){
        	List<Hero> heroesList = heroService.findAllHeroes();
        	return new ResponseEntity<>(heroesList, HttpStatus.OK);
        }
        
dans l'ordre:
- l'annotaion @GetMapping('url') informe la fonction à venir qu'elle doit se declencher à reception de l'url en parametre. elle indique aussi la nature de la requete, GET (aller récuperer quelque chose).
- c'est la fonction getAllHeroes() va renvoyer un objet de type ResponseEntity qui contiendra une liste d'objets de type Hero.
- cette liste nous sera fournie par une fonction qu'on va aller appeler dans le service (HeroService)
- on donne cette liste et un status http OK en retour, emballés dans un ResponseEntity, pour le FRONT

Côté service (HeroService).

        public List<Hero> findAllHeroes(){
        		return HeroRepository.findAll();
        	}
        	
Pas grand chose ici car le service appel une fonction du Repository déja toute prete, findAll()


Notre liste de heros en DB est créee et passée ensuite dans l'autre sens jusqu'à notre controleur

### 9-cRud , la suite{#9}

qui peut le plus peut le moins, nous allons maintenant recuperer un seul heros

Côté controlleur (HeroController):


    @GetMapping("/find/{id}")
    public ResponseEntity<Hero> getHeroById(@PathVariable("id") Long id){
    	Hero hero = heroService.findHeroById(id);
    	return new ResponseEntity<>(hero, HttpStatus.OK);
    } 
    
même structure ici.
- Une annotation correspondant à une requete de type GET, associée à une URL.
la particularité de cette URL est qu'elle fait reference à une id dynamique, qui correspondra à celle de l'objet requeté côté FRONT. Une id dynamique est passée entre crochets.

- notre fonction va renvoyer un ResponseEntity egalement mais celui-ci ne contiendra qu'un seul objet de type Hero. Puiqu'on doit trouver le héros correspondant à son id dans la DB, on passe l'id de l'URL en parametre de notre fonction. l'annotation **@PathVariable("id")** indique que l'id est celle passée via l'URL.
- on appel la fonction du service correspondante, toujours en passant l'id et on stock son resultat dans une variable de type Hero.
- celle-ci est emballée avec un status http ok au sein d'un Response Entity.


Côté service (HeroService):

Idem, on appel une fonction du service ( findHeroById(id) ) qui appel une fonction du Repository. La particularité dans ce cas, c'est qu'on ne fait pas appel à une fonction toute prete du Repository, mais une fonction "maison". La raison pour laquelle on fait ça est que la fonction toute prete du Repository ne sait pas qu'elle doit renvoyer un objet de type Hero. On crée donc une fonction adaptée qui renvoit un objet de type Hero qui pourra etre recuperée par notre Front, à l'autre bout de la chaine. C'est une des force de JPA, qui propose des fonctions "clé en main" mais offre aussi la possibilite de créer ses propres fonctions adaptées à ses besoins.

### 10-cRud , la suite{#10}

Modifions un élément de notre DB. Côté controlleur (HeroControler):

    @PutMapping("/update")
    public ResponseEntity<Hero> updateHero(@RequestBody Hero hero){
      Hero updatedHero = heroService.updateHero(hero);
      return new ResponseEntity<>(updatedHero, HttpStatus.CREATED);
    }

Même punition.
- Une annotation adaptée ( ici de type PUT, avec une URL qui va bien ).
- notre fonction prend en parametre le hero, sélectionné côté FRONT, que l'on va éditer. Notez la présence d'une nouvelle annotation **@RequestBody** qui indique que la requete amène un objet avec toutes ses proprietés, car on ne sait pas à l'avance la ou lesquelles on va modifier.
- On appele la fonction updateHero(hero) du service qui appel la fonction toute prete du Repository, save(hero). on stock le héros modifié dans une variable locale.
- on renvoit cette variable et son contenu avec un http status OK.

### 11- cruD, Delete{#11}

Vous commencez à prendre le pli peut-etre:

    @DeleteMapping("/delete/{id}")
    public ResponseEntity<Hero> deleteHero(@PathVariable("id") Long id){
      heroService.deleteHeroById(id);
      return new ResponseEntity<>(HttpStatus.OK);
    }

Comme pour le find, on trouve le heros à effacer grâce à son id, donc on la passe dynamiquement dans l'URL. Notez aussi le type de l'annotation.
le service appel sa fonction delete qui appele celle du Repository.

### 12-Crud, Create{#12}

Bon mais c'est plus sympa de créer des heros que de les supprimer non? 

    @PostMapping("/add")
    public ResponseEntity<Hero> addHero(@RequestBody Hero hero){
      Hero newHero = heroService.addHero(hero);
      return new ResponseEntity<>(newHero, HttpStatus.CREATED);
    }

Une annotation de type POST, l'URL qui va bien. le service appel son add, qui appel le save du repository. Mais pas si vite!
Car si on crée un Heros il lui faut un nom et un pouvoir, ce sont ses proprietés, et, normalement, côté FRONT on a surement rempli un formulaire avec ces infos là.
Comment vont-elles arriver jusu'au repository?
Rappelez vous, l'annotation @RequestBody nous envoit un Heros complet. Celui-ci passe dans notre service et c'est là qu'on va definir les proprietés de notre héros.

la methode addHero(hero) dans HeroService:

    public Hero addHero(Hero hero) {
        hero.setNom(hero.getNom());
        hero.setPouvoir(hero.getPouvoir());
        
        return HeroRepository.save(hero);
      }


Que se pase-t'il ? on utilise les getters et setters de notre classe Hero ( depuis le temps qu'il ne servaient à rien ils devaient s'ennuyer ) tout simplement, puis on utilise la methode save() du repository, à laquelle on passe le nouveau héros tout frais. C'est ce nouveau heros qui sera renvoyé en FRONT.

### 13-crUd, update{#13}
---
todo
---

### 14- Premier bilan{#14}

On constate que JPA, avec sa classe JpaRepository nous facilite la vie avec des methodes toute pretes pour gerer les principales fonctions liées au CRUD. Il est aussi suffisament souple pour nous permettre de surcharger ses fonctions ou en créer des maisons adaptées à nos besoins. C'est l'avantage énorme que nous apporte les **interfaces**.

Pourquoi avoir besoin d'un couche service?

La couche service va faire du traitement et du controle de données en amont et en aval du repository. dans le cas d'un Add, il prepare l'objet avant qu'il soit enregistré en DB. la couche service nous permet de faire de la gestion d'exception, et donc d'ameliorer la robustesse et la sécurité de notre application, comme nous allons le voir dans le prochaine exemple.

### 15-Quand ça marche c'est bien mais quand ça marche pas?{#15}

Reprenons l'exemple d'un aspect du CRUD, le "find by id". on souhaite récuperer un élement en appelant son Id.

IL peut arriver:
1- que l'on recherche un élément qui n'existe pas
2- ou qui ne soit pas du bon type.
Si l'on regarde notre fonction findHeroById(id) dans HeroRepo, elle renvoit un objet de type Hero. donc dans le premier cas, la fonction ne renverra pas un Hero vide, il y a un risque d'erreur. Dans le second cas, il y aura une erreur.

Une solution serait d'utiliser un objet **Optionnal** contenant un objet de type Hero. Comme son nom l'indique, un objet Optionnal comprendra qu'il n'est pas necessaire d'obtenir à tout prix un objet Hero. Cela nous permet par la suite, dans la fonction findHeroById(Long id) de **HeroService**, de surveiller une eventuelle exception et donc d'ajouter un comportement adapté aux 2 cas présentés precedemment.

la nouvelle fonction findHeroById(id) dand HeroRepo:

    Optional<Hero> findHeroById(Long id);



la nouvelle fonction findHeroById(Long id) de HeroService:

    public Hero findHeroById(Long id) { return HeroRepository.findHeroById(id)
            .orElseThrow( () -> new HeroNotFoundException("Hero by id not found"));
      }

Ici à notre return on a ajouter une fonction qui va creer une instance de la classe HeroNotFoundException(message: string). Créons cette classe dés maintenant dans un package nommé **Exception**, elle est tres simple:

  <package racine>.exception;

  public class HeroNotFoundException extends RuntimeException {

    public HeroNotFoundException(String message) {
      super(message);
    }
  }


### 16-Conclusion?{#16}

Voilà à quoi devrait resembler notre projet BACK. Observez bien comment sont formées nos classe HeroControler, HeroService et HeroRepo.
(lien vers le repo du projet back).

*HeroControler:*

Les points importants à noter. Il y a deux annotions qui precedent la declaration de notre classe.

@RestController: Elle indique à Spring que cette classe est un controleur de type REST, qui va gérer la reception d'URL et appeler les services adaptés.

@RequestMapping("/hero"): Elle va definir la racine des URL liées aux opérations CRUD. On idique au controlleur qu'il attend les URL suivantes:

http://localhost:8080/hero/...

http://localhost:8080/hero/all -> récuperation de tous les héros
http://localhost:8080/hero/find/{id} ->récupération d'un héros
http://localhost:8080/hero/add -> ajout d'un héros
http://localhost:8080/hero/update -> edition d'un héros
http://localhost:8080/hero/delet/{id} -> suppression d'un héros

on declare un objet de type HeroService.

dans le constructeur de notre classe HeroControler nous passons en paramétre l'objet de type HeroService, que l'on va ensuite créer. L'annotation @Autowirred indique à Spring qu'il doit injecter le service dans le controlleur.

*HeroService:*

Une annotaion @Service avant la déclaration de la classe indique qu'il s'agit d'un service.
On declare un objet de type HeroRepository.
@Autowirred avant le constructeur pour indiquer à la classe qu'on lui injecte HeroRepository.
on passe l'objet HeroRepository en parametre du constructeur et on l'instancie.


### 17-Attention ça se "**CORS**"{#17}

Vous avez un back et front qui marche mais L'application à ce stade n'est pas encore 100%fonctionnelle. Pourquoi?

Si vous êtes aussi impatient que moi vous avez sans doute déja lancé votre back et votre front pour tout tester, cependant il y a un pépin.
ouvrons notre front dans un navigateur internet. Affichons les outils de devellopement de ce navigateur. Dans l'onglet Console, nous pouvons observer ce qui va se passser.
Testons une fonctionnalité, comme un ajout de héros par exemple. Dans la console vous devriez voir quelquechose de ce genre s'afficher:

    Access to XMLHttpRequest at 'http://localhost:8080/hero/add' from origin 'http://localhost:4200' has been blocked by CORS policy: Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource.

Le probléme est le suivant: Notre FRONT est situé en localhost:4200 et notre Back est situé en localhost:8080. Pour des raisons de sécurité les navigateurs internet empechent les requetes de passer d'un domain à un autre. Cela evite qu'un site malveillant situé sur un domaine puisse interagir avec le sitre de votre banque sur situé sur autre domaine. Logique, mais cela nous empeche de travailler.

La solution: Indiquer à Spring que l'on va autoriser les échanges entre nos deux domaines. Pour cela on va injecter du code dans la classe pricipale de notre projet BACK.
 Alors là il va falloir me faire confiance et juste coller cette portion de code dans la classe principale:

    @Bean
	public CorsFilter corsFilter() {
		CorsConfiguration corsConfiguration = new CorsConfiguration();
		corsConfiguration.setAllowCredentials(true);
		corsConfiguration.setAllowedOrigins(Arrays.asList("http://localhost:4200"));
		corsConfiguration.setAllowedHeaders(Arrays.asList("Origin", "Access-Control-Allow-Origin", "Content-Type",
				"Accept", "Authorization", "Origin, Accept", "X-Requested-With",
				"Access-Control-Request-Method", "Access-Control-Request-Headers"));
		corsConfiguration.setExposedHeaders(Arrays.asList("Origin", "Content-Type", "Accept", "Authorization",
				"Access-Control-Allow-Origin", "Access-Control-Allow-Origin", "Access-Control-Allow-Credentials"));
		corsConfiguration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
		UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = new UrlBasedCorsConfigurationSource();
		urlBasedCorsConfigurationSource.registerCorsConfiguration("/**", corsConfiguration);
		return new CorsFilter(urlBasedCorsConfigurationSource);
	}


Notons à la ligne:

     corsConfiguration.setAllowedOrigins(Arrays.asList("http://localhost:4200"));

on met l'adresse de notre FRONT. Voilà on peut maintenant communiquer sans soucis entre FRONT et BACK.




### 18-Aller plus loin{#18}

Nous avons désormais un BACK fonctionnel, qui si tout va bien, est raccordé à notre FRONT. Que fait notre application ? Nous affichons un ensemble de héros ainsi que leurs nom et pouvoir. On peut ajouter, éditer, ou supprimer un héros.



Une fonctionnalité qui serait interessante à implementer serait de pouvoir créer une équipe de héros, qui aurait ses propres caractéristiques.
Comment cela pourrait se traduire côté BACK?

Niveau DB, il faudrait ajouter une table Team avec une id en clé primaire et un nom.
Dans la table Hero, il faudra ajouter une clé étrangere liée à l'id de la table equipe.

Au niveau de notre projet nous allons créer une nouvelle entité Equipe qui aura son propre CRUD, et donc son propre controlleur et son propre service.

### 19-JPA à la rescousse!{#19}

La force de JPA est de pouvoir faire les deux simultanéments directement à l'aide de notre code et sans passer par la case bash MySQL.

Il est important de noter le lien entre la classe de l'entité et son impact sur la base de données. Quand on crée une classe que l'on declare ensuite à Spring comme étant une entité ( avec l'annotation @Entity ), JPA créé une table du nom de la classe, et des collones nommées selon les proprietes de la classe. Via le code, on peut aussi mettre en place les relations entre les tables, telles que One To Many, ou Many to One, etc...

Il faut donc, avant de coder, reflechir à nos données, tables et relations.

Dans notre projet, un héros pourra appartenir à une et seulement une equipe, et une equipe pourra contenir un ou plusieurs héros. il s'agit donc d'une relation:
- One To Many du point de vue Team
- Many To One du point de vue Hero

Pour illustrer le propos, observons une classe Parent et une classe Enfant qui vont appliquer ces préceptes.

Classe Parent ( Abrégée pour une meilleure lisibilité ):

    package xxx;

    
    imports
    ...
    ...

    @Entity
    public class Parent {

    @OneToMany(mappedBy = "parent")
    private List<Enfant> enfants;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(nullable = false, updatable = false)
    private Long id;

    private String nom;


    public Parent() {
    }


        //Getters et Setters
        //...
        //...
    }


Ce sont les annotations qui vont "habiller" notre classe et informer JPA de leur rôle au sein de la table qui va etre créée.

- @Entity: declare l'entité
- @OneToMany(mapedBy = ""): On met en place la relation avec une future table enfant ( qu'on va décrire plus loin ), en associant cette annotation avec une collection d'objets de type Enfant.
- @Id, @GeneatedValue(...), @Column se chargent de declarer une collone id  auto incrémentée non nullable et non modifiable.

La classe Enfant:

    package xxx;

    imports
    ...
    ...

    @Entity

    public class Enfant {


    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;

    private String nom;
    private String prénom;

    @ManyToOne
    @JoinColumn(name = "parent_id")
    private Parent parent;

        public Enfant() {}
        

        //Getters et Setters
    }


- Même démarche ici sauf que la relation est de type Many To One
- @JoinColumn va créer une colonne parent_id qui fera reference à la clé primaire(id) de la table parent. Il faut donc lui donner une reference à un objet de type parent.

Voici à quoi les tables devraient ressembler:

table parent:

    field     type      null      key     default     extra
    id        bigint    no        PRI     NULL        auto_increment
    nom       varchar   yes               NULL



table enfant:

    field     type      null      key     default     extra
    id        bigint    no        PRI     NULL        auto_increment
    nom       varchar   yes               NULL
		prenom    varchar   yes               NULL
    parent_id bigint    yes       MUL     NULL










    
